---
title: UI Testing
description: Custom UI testing is an optional feature that enables you to create and automatically run UI tests for your custom applications
exl-id: 3009f8cc-da12-4e55-9bce-b564621966dd
---

# UI Testing {#ui-testing}

>[!CONTEXTUALHELP]
>id="aemcloud_nonbpa_uitesting"
>title="UI Testing"
>abstract="Custom UI testing is an optional feature that enables you to create and automatically run UI tests for your applications. UI tests are Selenium-based tests packaged in a Docker image in order to allow a wide choice in language and frameworks (such as Java and Maven, Node and WebDriver.io, or any other framework and technology built upon Selenium)."

Custom UI testing is an optional feature that enables you to create and automatically run UI tests for your applications.
 
## Overview {#custom-ui-testing}

AEM provides an integrated suite of [Cloud Manager quality gates](/help/implementing/cloud-manager/custom-code-quality-rules.md) to ensure smooth updates to custom applications. In particular, IT test gates already creation and automation of custom tests using AEM APIs.

UI tests are Selenium-based tests packaged in a Docker image in order to allow a wide choice in language and frameworks (such as Java and Maven, Node and WebDriver.io, or any other framework and technology built upon Selenium). Additionally a UI tests project can easily be generated by using [the AEM Project Archetype.](https://experienceleague.adobe.com/docs/experience-manager-core-components/using/developing/archetype/overview.html)

UI tests are executed as part of a specific quality gate for each Cloud Manager pipeline with a [dedicated **Custom UI Testing** step.](/help/implementing/cloud-manager/deploy-code.md) Any UI tests including regression and new functionalities enables errors to be detected and reported.

Unlike custom functional tests, which are HTTP tests written in Java, UI tests can be a Docker image with tests written in any language, as long as they follow the conventions defined in the section [Building UI Tests.](#building-ui-tests)

>[!TIP]
>
>Adobe recommends following the structure and language (JavaScript and WDIO) provided in the [AEM Project Archetype.](https://github.com/adobe/aem-project-archetype/tree/master/src/main/archetype/ui.tests) 

### Customer Opt-In {#customer-opt-in}

In order for Cloud Manager to build and execute you UI tests, you must opt into this feature by adding a file to your repository. 

* The file name must be `testing.properties`.
* The file contents must be `ui-tests.version=1`.
* The file must be under the maven sub-module for UI tests next to the `pom.xml` file of the UI tests submodule.
* The file must be at the root of the built `tar.gz` file.

The UI tests build and executions will be skipped if this file is not present.

To include a `testing.properties` file in the build artifact, add an `include` statement in the `assembly-ui-test-docker-context.xml` file. 

```xml
[...]
<includes>
    <include>Dockerfile</include>
    <include>wait-for-grid.sh</include>
    <include>testing.properties</include> <!- opt-in test module in Cloud Manager -->
</includes>
[...]
```

>[!NOTE]
>
>If your project does not include this line, you will need to edit the file to opt into UI testing.
>
>The file may contain a line advising not to edit it. This is due to it being introduced into your project before opt-in UI testing was introduced and client's were not intended to edit the file. This can be safely ignored.

## Building UI Tests {#building-ui-tests}

A Maven project generates a Docker build context. This Docker build context describes how to create a Docker image containing the UI tests, which Cloud Manager users to generate a Docker image containing the actual UI tests.

This section describes the steps needed to add a UI tests project to your repository. 

>[!TIP]
>
>The [AEM Project Archetype](https://github.com/adobe/aem-project-archetype) can generate a UI Tests project for you don't have special requirements for the programming language.

### Generate a Docker Build Context {#generate-docker-build-context}

In order to generate a Docker build context, you need a Maven module that:

* Produces an archive that contains a `Dockerfile` and every other file necessary to build the Docker image with your tests.
* Tags the archive with the `ui-test-docker-context` classifier.

The simplest way to do this is to configure the [Maven Assembly Plugin](https://maven.apache.org/plugins/maven-assembly-plugin/) to create the Docker build context archive and assign the right classifier to it.

You can build UI tests with different technologies and frameworks, but this section assumes that your project is laid out in a way similar to the following.

```text
├── Dockerfile
├── assembly-ui-test-docker-context.xml
├── pom.xml
├── test-module
│   ├── package.json
│   ├── index.js
│   └── wdio.conf.js
└── wait-for-grid.sh
```

The `pom.xml` file takes care of the Maven build. Add an execution to the Maven Assembly Plugin similar to the following.

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-assembly-plugin</artifactId>
    <configuration>
        <descriptors>
            <descriptor>${project.basedir}/assembly-ui-test-docker-context.xml</descriptor>
        </descriptors>
        <tarLongFileMode>gnu</tarLongFileMode>
    </configuration>
    <executions>
        <execution>
            <id>make-assembly</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

This execution instructs the Maven Assembly Plugin to create an archive based on the instructions contained in `assembly-ui-test-docker-context.xml`, called an **assembly descriptor** in the plugin's jargon. The assembly descriptor lists all the files that must be part of the archive.

```xml
<assembly>
    <id>ui-test-docker-context</id>
    <includeBaseDirectory>false</includeBaseDirectory>
    <formats>
        <format>tar.gz</format>
    </formats>
    <fileSets>
        <fileSet>
            <directory>${basedir}</directory>
            <includes>
                <include>Dockerfile</include>
                <include>wait-for-grid.sh</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${basedir}/test-module</directory>
            <excludes>
                <exclude>node/**</exclude>
                <exclude>node_modules/**</exclude>
                <exclude>reports/**</exclude>
            </excludes>
        </fileSet>
    </fileSets>
</assembly>
```

The assembly descriptor instructs the plugin to create an archive of type `.tar.gz` and assigns the `ui-test-docker-context` classifier to it. Moreover, it lists the files that must be included in the archive including the following.

* A `Dockerfile`, mandatory for building the Docker image
* The `wait-for-grid.sh` script, whose purposes are described below
* The actual UI tests, implemented by a Node.js project in the `test-module` folder

The assembly descriptor also excludes some files that might be generated while running the UI tests locally. This guarantees a smaller archive and faster builds.

The archive containing the Docker build context is automatically picked up by Cloud Manager, which will build the Docker image containing your tests during its deployment pipelines. Eventually, Cloud Manager will run the Docker image to execute the UI tests against your application.

The build should produce either zero or one archive. If it produces zero archives, the test step passes by default. If the build produces more than one archive, which archive is selected is non-deterministic.

## Writing UI Tests {#writing-ui-tests}

This section describes the conventions that the Docker image containing your UI tests must follow. The Docker image is built out of the Docker build context described in the previous section.

### Environment Variables {#environment-variables}

The following environment variables will be passed to your Docker image at run time.

|Variable|Examples|Description|
|---|---|---|
|`SELENIUM_BASE_URL`|`http://my-ip:4444`|The URL of the Selenium server|
|`SELENIUM_BROWSER`|`chrome`|The browser implementation used by the Selenium Server|
|`AEM_AUTHOR_URL`|`http://my-ip:4502/context-path`|The URL of the AEM author instance|
|`AEM_AUTHOR_USERNAME`|`admin`|The user name to login to the AEM author instance|
|`AEM_AUTHOR_PASSWORD`|`admin`|The password to login to the AEM author instance|
|`AEM_PUBLISH_URL`|`http://my-ip:4503/context-path`|The URL of the AEM publish instance|
|`AEM_PUBLISH_USERNAME`|`admin`|The user name to login to the AEM publish instance|
|`AEM_PUBLISH_PASSWORD`|`admin`|The password  to login to the AEM publish instance|
|`REPORTS_PATH`|`/usr/src/app/reports`|The path where the XML report of the test results must be saved|
|`UPLOAD_URL`|`http://upload-host:9090/upload`|The URL where file must be uploaded to in order to make them accessible to Selenium|

### Waiting for Selenium to be Ready {#waiting-for-selenium}

Before the tests start, it's the responsibility of the Docker image to ensure that the Selenium server is up and running. Waiting for the Selenium service is a two-steps process.

1. Read the URL of the Selenium service from the `SELENIUM_BASE_URL` environment variable.
1. Poll at regular interval to the [status endpoint](https://github.com/SeleniumHQ/docker-selenium/#waiting-for-the-grid-to-be-ready) exposed by the Selenium API.

Once the Selenium's status endpoint answers with a positive response, the tests can start.

### Generate Test Reports {#generate-test-reports}

The Docker image must generate test reports in the JUnit XML format and save them in the path specified by the environment variable `REPORTS_PATH`. The JUnit XML format is a widely-used format for reporting the results of tests. If the Docker image uses Java and Maven, standard test modules such as [Maven Surefire Plugin](https://maven.apache.org/surefire/maven-surefire-plugin/) and [Maven Failsafe Plugin](https://maven.apache.org/surefire/maven-failsafe-plugin/) can generate such reports out of the box.

If the Docker image is implemented with other programming languages or test runners, check the documentation for the chosen tools for how to generate JUnit XML reports.

### Upload Files {#upload-files}

Tests sometimes must upload files to the application being tested. In order to keep the deployment of Selenium flexible relative to your tests, it is not possible to directly upload an asset directly to Selenium. Instead, uploading a file requires the following steps.

1. Upload the file at the URL specified by the `UPLOAD_URL` environment variable.
   * The upload must be performed in one POST request with a multipart form.
   * The multipart form must have a single file field.
   * This is equivalent to `curl -X POST ${UPLOAD_URL} -F "data=@file.txt"`.
   * Consult the documentation and libraries of the programming language used in the Docker image to know how to perform such an HTTP request.
1. If the upload is successful, the request returns a `200 OK` response of type `text/plain`.
   * The content of the response is an opaque file handle.
   * You can use this handle in place of a file path in an `<input>` element to test file uploads in your application.
